Augusta Ada Byron
Augusta Ada Byron, que era el nombre real de Ada Lovelace (tras casarse pasó a llamarse Augusta Ada King, Condesa de Lovelace y de ahí procede "Ada Lovelace"), nació en la ciudad de Londres el 10 de diciembre de 1815. Su padre era, nada más y nada menos, que el poeta inglés Lord Byron y su esposa la baronesa Anne Isabella Byron (de hecho, fue su único vástago legítimo y dentro del matrimonio), sin embargo, el padre de Ada se separó de su esposa al mes del nacimiento de su hija y, cuatro meses más tarde, abandonaría Inglaterra, a la que nunca más regresó.

La madre de Ada promovió en su hija el interés por las matemáticas y la lógica para evitar, de esta forma, fomentar el carácter de Lord Byron en Ada. A pesar de esta inmersión en las ciencias, Ada Lovelace no se alejó ni de su padre ni de su legado, a pesar de que éste muriese cuando ella ni había cumplido los 9 años de edad. Su madre siempre pensó que las ciencias la apartarían de la "locura" e su padre y Ada recibió clases de tutores como William Frend y Mary Sommerville en matemáticas y Augustus De Morgan en lógica; unos tutores que vieron claro la predisposición de su alumna al aprendizaje de estas materias y su talento para las matemáticas.

Además de crecer sin su padre, la infancia de Ada Lovelace no fue sencilla. Sufrió un grave brote de sarampión, a la edad de 14 años, que la mantuvo en cama casi un año y luego estuvo otro año más dependiendo de unas muletas para caminar.

A pesar de este impedimento, Ada se centró aún más en su educación científica y Mary Sommerville, una de sus tutoras, le presentó a una figura que sería clave en su vida: Charles Babbage.

La máquina analítica de Charles Babbage

Charles Babbage fue un matemático británico que sentó los pilares fundamentales sobre los que se desarrolló la computación. Diseñó y construyó parcialmente una máquina para calcular diferencias numéricas y obtener tablas de números y, además, elaboró un modelo teórico en el que definió una máquina analítica capaz de ejecutar programas y, por tanto, realizar cualquier tipo de cálculo.

Maquina Analitica de Babbage - Ada Lovelace
Imagen: Bruno Barral
La idea de Babbage, aunque era algo innovador, no se pudo llevar a la práctica por algo tan mundano como la falta de financiación, los continuos cambios que hacía Babbage en el diseño y por no encontrar este matemático materiales de calidad para llevar a cabo su invento. Sin embargo, el encuentro propiciado por Mary Sommerville entre Ada Lovelace y Charles Babbage tendría un gran calado para el mundo de la computación.



Ada Lovelace se interesó, desde un primer momento, por el trabajo de Babbage con sus máquinas analíticas y diferenciales. Ada fue una de las grandes promotoras y defensoras del proyecto, entabló una profunda amistad con Babbage y analizó en profundidad las posibilidades de este tipo de máquinas más allá de su uso para la realización de cálculos matemáticos. Gracias a Ada Lovelace, el diseño de la máquina analítica se perfeccionó y, por ejemplo, se modeló algo que veríamos en la primera generación de computadores digitales que surgieron tras la Segunda Guerra Mundial: las tarjetas perforadas como dispositivos de entrada.

Fruto de esta colaboración entre Ada Lovelace y Charles Babbage, el matemático encargaría a su colaboradora (que no ayudante) la traducción de un artículo sobre la máquina analítica escrito por el matemático italiano italiano Luigi Menabrea.




                                                  El primer lenguaje de programación

Esta traducción, realizada entre 1842 y 1843, puede considerarse un punto de inflexión en el campo de las ciencias de la computación. Además de traducir el artículo, Ada Lovelace complementó el texto con aportaciones propias, unas anotaciones denominadas "Notas" que materializaban algo desconocido por aquel entonces: un programa de ordenador.

Esta máquina puede hacer cualquier cosa que sepamos cómo ordenarle que la ejecute

Las anotaciones de Ada Lovelace sobre el artículo de Luigi Menabrea, relativo a la máquina analítica, resultaron ser un algoritmo codificado para que este primitivo (y teórico) computador lo ejecutase. Entre sus notas, Lovelace diseñó un programa para calcular los números de Bernoulli con la máquina (y que por cierto usaba dos bucles para realizar los cálculos); un programa que es considerado como el primer software de la historia y hace que Ada Lovelace sea reconocida como la primera programadora.

Día de Ada Lovelace 2012
Imagen: Día de Ada Lovelace 2012. Wikipedia
Muerte y legado

Ada Lovelace murió a la edad de 36 años, el 27 de noviembre de 1852, víctima de un cáncer de útero y, seguramente, por las complicaciones debidas al tratamiento a base de sangrías que aplicaron sus médicos. En los meses previos a su muerte, se volvió profundamente religiosa, rompió con su vida anterior e, incluso, perdió el contacto con su esposo. Su último deseo fue ser enterrada junto a su padre, Lord Byron, en la Iglesia de Santa María Magdalena en Hucknall, Nottingham.

Durante años, el trabajo de Ada Lovelace fue olvidado para muchos por el simple hecho de ser mujer. En un principio, a Ada se le atribuyó el papel de asistente/transcriptora de Babbage; sin embargo, la realidad es que sus investigaciones eran propias y, hoy en día, es considerada como la madre de la programación.

Placa conmemorativa Ada Lovelace
Imagen: Adam Bowie en Flickr
El reconocimiento a Ada Lovelace y su trabajo llegó, realmente, en el siglo XX cuando surgieron los primeros computadores y lenguajes de programación. Hoy en día, Ada Lovelace es considerada una figura clave cuyo trabajo y legado recordamos cada año y que, también, se ha recordado en forma de algunas iniciativas y proyectos:

En 1979, el Departamento de Defensa de Estados Unidos creó el lenguaje de programación Ada basándose en Pascal y, por ahora, es la única mujer que cuenta con un lenguaje de programación que lleva su nombre.

Microsoft utiliza un retrato de Ada Lovelace como marca de autenticidad de los certificados de licencia de Windows.

Divide y venceras en school

Se denomina esqueleto algorítmico a un conjunto de procedimientos que constituyen el armazón con el que desarrollar programas para resolver un problema dado utilizando una técnica particular. Este software presenta declaraciones de clases vacías que el usuario ha de rellenar para adaptarlo a la resolución de un problema concreto. La librería MaLLBa se ha diseñado de forma que la tarea de la persona que adapta el problema real al esqueleto sea lo más simple posible. En un esqueleto MaLLBa se distinguen dos partes principales: una parte que implementa el patrón de resolución y que es completamente proporcionada por la librería, y una parte que el usuario ha de acabar de completar con las características particulares del problema a resolver y que será utilizada por el patrón de resolución. En el diseño de los esqueletos se ha utilizado la Orientación a Objetos (00). La facilidad de interpretación del esqueleto es una de las ventajas que aporta esta filosofía, además de las de modularidad, reusabilidad y modificabilidad. Existe una relación bastante intuitiva entre las entidades participantes en el patrón de resolución y las clases que ha de implementar el usuario. Figura 1. Arquitectura de los Esqueletos MaLLBa. La parte proporcionada por el esqueleto, esto es, los patrones de resolución, se implementan mediante clases en las que explícitamente se indica que son definidas por el esqueleto. A estas clases se les da el nombre de clases proporcionadas y aparecen en el código con el calificativo provides. 5 La parte que ha de completar el usuario con la instanciación de su problema particular se implementa mediante clases marcadas con el calificativo requires, se las denominará clases requeridas. La adaptación que ha de realizar el usuario consiste en representar mediante las estructuras de datos necesarias su problema e implementar (en función de dicha representación) las funcionalidades requeridas por los métodos de las clases. Estas clases serán invocadas desde el patrón de resolución particular (por que conoce la interfaz para dichas clases) de forma que, cuando la instanciación se ha completado, se obtienen las funcionalidades esperadas aplicadas al problema concreto del usuario. La Figura 1, presenta la arquitectura del esqueleto. En el fichero con extensión .hh se definen las cabeceras de las clases requeridas y proporcionadas. El fichero .pro.cc contiene las implementaciones C++ de los patrones de resolución, mientras que el fichero .req.cc es el que ha de implementar el usuario. 2.1. Clases Requeridas La solución de un problema de optimización combinatoria en general consiste en un vector de enteros que cumple un número de restricciones y optimiza una función objetivo. La función objetivo debe ser maximizada o minimizada. Partiendo de esta descripción, se abstrae que en un esqueleto deben representarse mediante clases tanto el problema como la solución. Las clases requeridas se utilizan para almacenar los datos básicos del algoritmo. Con ellas se representan el problema, la solución, los estados del espacio de búsqueda y la entrada/salida. Todos los esqueletos MaLLBa han de definir las siguientes clases: • Problem: define la interfaz mínima estándar necesaria para representar un problema. • Solution: define la interfaz mínima estándar necesaria para representar una solución. Cada patrón de resolución requiere además un conjunto de clases propias de la técnica algorítmica. En los epígrafes siguientes se describen las clases que el usuario ha de implementar cuando utilice MaLLBa::DnC y MaLLBa::BnB. 2.1.1 Interfaz del esqueleto de Divide y Vencerás Para instanciar un esqueleto MaLLBa::DnC además de las clases Problem y Solution, es necesario implementar las clases SubProblem y Auxiliar (véase la Figura 2). • La clase SubProblem: representa una partición de un problema en partes disjuntas. Esta clase se ha introducido en aras de una mayor eficiencia en la implementación. La alternativa hubiera sido, representar a los sub-problemas para que fueran del mismo tipo que los problemas. Esta clase debe proporcionar las siguientes funcionalidades: - initSubProblem(pbm): Inicializa el subproblema de partida a partir del problema original. - easy (pbm): Determina si un subproblema es lo suficientemente pequeño para ser considerado simple. - solve(pbm, sol): Proporciona el algoritmo básico de resolución para subproblemas fáciles. - divide (pbm, sps, aux): Genera una lista de subproblemas. • La clase Auxiliar: en algunos casos es necesario el uso de una clase auxiliar. Su necesidad se hace patente cuando como resultado de dividir el problema se obtiene una partición que no constituye un subproblema. • Además la clase Solution debe proporcionar la siguiente funcionalidad: - combine(pbm, sols, aux): dado un conjunto de soluciones parciales de subproblemas, este método ha de combinarlas para crear una nueva solución parcial más general. 6 Figura 2. Clases requeridas por el esqueleto de Divide y Vencerás 2.1.2. Interfaz del esqueleto de Ramificación y Acotación Los algoritmos de Ramificación y Acotación dividen el área de soluciones paso a paso y calculan una cota del posible valor de aquellas soluciones que pudieran encontrarse más adelante. Si la cota muestra que cualquiera de estas soluciones tiene que ser necesariamente peor que la mejor solución hallada hasta el momento, entonces no es necesario seguir explorando esta parte del árbol. Por lo general, el cálculo de cotas se combina con un recorrido en anchura o en profundidad. Para representar este proceso en un esqueleto, se utilizará la clase Subproblem. Así pues, el esqueleto MaLLBa::BnB a diferencia de MaLLBa::DnC sólo requiere que el usuario Ie suministre dicha clase (véase la Figura 3). Además el usuario debe especificar en la definición de la clase Problem si el problema a resolver es de máximo o de mínimo. • La clase Subproblem: representa el área de soluciones no exploradas. Esta clase debe propor



                                                      formulas de graficas 
                                                      
3))sqrt(1-(x/7)^2)+(5+0.97(abs(x-.5)+abs(x+.5))-3(abs(x-.75)+abs(x+.75)))(1+abs(1-
abs(x))/(1-abs(x))),-3sqrt(1-(x/7)^2)sqrt(abs(abs(x)-4)/(abs(x)-4)),abs(x/2)-
0.0913722(x^2)-3+sqrt(1-(abs(abs(x)-2)-1)^2),(2.71052+(1.5-.5abs(x))-1.35526sqrt(4-
(abs(x)-1)^2))sqrt(abs(abs(x)-1)/(abs(x)-1))+0.9

+ (-sqrt(1-x^2-(y-abs(x))^2))*cos(30*((1-x^2-(y-abs(x))^2))), x is from -1 to 1, y is
from -1 to 1.5, z is from 1 to 6

100-3/(sqrt(x^2+y^2))+sin(sqrt(x^2+y^2))+sqrt(200-
(x^2+y^2)+10*sin(x)+10sin(y))/1000, x is from -15 to 15, y is from -15 to 15, z is from
90 to 101
